
äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼Œç®€å†™ BSTï¼‰

<https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-1/bst1>

<https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-1/er-cha-sou-suo-shu-cao-zuo-ji-jin>

<https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-1/bst3>

<https://programmercarl.com/0700.äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢.html#é€’å½’æ³•>

# æœç´¢

## 700. äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢ï¼ˆç®€å•ï¼‰
https://leetcode-cn.com/problems/search-in-a-binary-search-tree

é¢˜ç›®æè¿°ï¼šç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹å’Œä¸€ä¸ªå€¼ã€‚ ä½ éœ€è¦åœ¨BSTä¸­æ‰¾åˆ°èŠ‚ç‚¹å€¼ç­‰äºç»™å®šå€¼çš„èŠ‚ç‚¹ã€‚ è¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘ã€‚ å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› NULLã€‚

```python
class Solution:
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        # é€’å½’ æ—¶é—´å¤æ‚åº¦O(n), ç©ºé—´å¤æ‚åº¦O(n)
        if not root: return None

        if root.val == val:
            return root
        elif root.val < val:
            return self.searchBST(root.right, val)
        else:
            return self.searchBST(root.left, val)
            
        # è¿­ä»£ æ—¶é—´å¤æ‚åº¦O(n), ç©ºé—´å¤æ‚åº¦O(1)
        while root:
            if val == root.val:
                return root
            root = root.left if val < root.val else root.right
        return None

```

## 98. éªŒè¯äºŒå‰æœç´¢æ ‘ï¼ˆä¸­ç­‰ï¼‰
https://leetcode-cn.com/problems/validate-binary-search-tree

```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        # é€’å½’ æ—¶é—´å¤æ‚åº¦O(n), ç©ºé—´å¤æ‚åº¦O(n)
        def helper(node, lower = float('-inf'), upper = float('inf')) -> bool:
            if not node: return True
            
            val = node.val
            if val <= lower or val >= upper:
                return False

            return helper(node.right, val, upper) and helper(node.left, lower, val)

        return helper(root)
        
        # ä¸­åºéå† æ—¶é—´å¤æ‚åº¦O(n), ç©ºé—´å¤æ‚åº¦O(n)
        stack, inorder = [], float('-inf')
        
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if root.val <= inorder:
                return False
            inorder = root.val
            root = root.right

        return True
        
        # ç”¨ç»Ÿä¸€è¿­ä»£çš„æ¡†æ¶å†™ä¸­åºéå†ï¼Œåªè¦åœ¨æ‰“å°èŠ‚ç‚¹å€¼æ—¶åŠ ä¸ªåˆ¤æ–­å°±å¯ä»¥äº†ã€‚
        stack = [root]
        tmpval = float('-inf')

        while stack:
            cur = stack.pop()
            if cur:
                if cur.right: stack.append(cur.right)

                stack.append(cur)
                stack.append(None)

                if cur.left: stack.append(cur.left)
            else:
                cur = stack.pop()
                if cur.val <= tmpval:
                    return False
                tmpval = cur.val

        return True

```

## 530. äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®
https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/

é¢˜ç›®æè¿°ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å› **æ ‘ä¸­ä»»æ„ä¸¤ä¸åŒèŠ‚ç‚¹å€¼ä¹‹é—´çš„æœ€å°å·®å€¼** ã€‚å·®å€¼æ˜¯ä¸€ä¸ªæ­£æ•°ï¼Œå…¶æ•°å€¼ç­‰äºä¸¤å€¼ä¹‹å·®çš„ç»å¯¹å€¼ã€‚

é¢˜è§£ï¼šé‡‡ç”¨ä¸­åºéå†ï¼Œå¾—åˆ°çš„æ•°å€¼æœ‰åºï¼Œæ¯”è¾ƒæ¯ä¸€å¯¹å·®å€¼å³å¯ã€‚

```python
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        if not root: return -1
        stack = [root]
        pre = -1  # è®°å½•å‰é¢çš„æ•°å€¼
        min_ = float('inf')  # è®°å½•æœ€å°å€¼
        while stack:
            cur = stack.pop()
            if cur:
                if cur.right: stack.append(cur.right)
                stack.append(cur)
                stack.append(None)
                if cur.left: stack.append(cur.left)
            else:
                cur = stack.pop()
                if pre!=-1:
                    min_ = min(min_, cur.val-pre)
                pre = cur.val
                
        return min_
```

## 501. äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°
https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/

å’Œä¹‹å‰çš„é¢˜ä¸€æ ·ï¼Œä¹Ÿæ˜¯ä¸­åºéå†ï¼Œåœ¨æ‰“å°èŠ‚ç‚¹å€¼çš„æ—¶å€™éœ€è¦åšè®¡æ•°ã€‚

-   ç»Ÿä¸€è¿­ä»£çš„æ–¹å¼è¿›è¡Œä¸­åºéå†
    ```python
    class Solution:
        def findMode(self, root: TreeNode) -> List[int]:
            if not root: return []
            stack = [root]

            nums = []
            pre = None # è®°å½•éå†æ—¶å‰è€…èŠ‚ç‚¹çš„å€¼
            count = 0
            maxcount = 0
            while stack:
                cur = stack.pop()
                if cur:
                    if cur.right: stack.append(cur.right)
                    stack.append(cur)
                    stack.append(None)
                    if cur.left: stack.append(cur.left)
                else:
                    cur = stack.pop()
                    if pre == None:
                        count = 1
                    elif cur.val == pre:
                        count += 1
                    else:
                        count = 1
                    
                    if count == maxcount:
                        nums.append(cur.val)
                    if count > maxcount:
                        maxcount = count
                        nums.clear()
                        nums.append(cur.val)

                    pre = cur.val
                    
            return nums
    ```
-   é€’å½’çš„è¯æ€ä¹ˆå†™ï¼Ÿä¸ºäº†ä»£ç é€»è¾‘æ¸…æ™°ï¼ŒæŠŠé€’å½’éå†çš„éƒ¨åˆ†å–å‡ºå°è£…æˆæ–°å‡½æ•°ã€‚
    ```python
    class Solution:
        def __init__(self):
            self.pre = TreeNode()
            self.count = 0
            self.max_count = 0
            self.result = []

        def findMode(self, root: TreeNode) -> List[int]:
            if not root: return None
            self.search_BST(root)
            return self.result
            
        def search_BST(self, cur: TreeNode) -> None:
            if not cur: return None
            self.search_BST(cur.left)
            # ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
            if not self.pre:
                self.count = 1
            # ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼ç›¸åŒ
            elif self.pre.val == cur.val:
                self.count += 1 
            # ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼ä¸ç›¸åŒ
            else:
                self.count = 1
            self.pre = cur

            if self.count == self.max_count:
                self.result.append(cur.val)
            
            if self.count > self.max_count:
                self.max_count = self.count
                self.result = [cur.val]  # æ¸…ç©ºself.resultï¼Œç¡®ä¿resultä¹‹å‰çš„çš„å…ƒç´ éƒ½å¤±æ•ˆ
            
            self.search_BST(cur.right)
    ```

## 230. BSTç¬¬Kå°çš„å…ƒç´ ï¼ˆä¸­ç­‰ï¼‰
https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst

è¿™é¢˜ç®€å•çš„åšæ³•å°±æ˜¯ ä¸­åºéå†+è®¡æ•°ï¼Œå°±å¯ä»¥å¾—åˆ°ç»“æœã€‚
å®˜æ–¹ç»™å‡ºçš„è§£ç­”æ¯”è¾ƒæœ‰æ„æ€ï¼Œç»™å‡ºäº†å…¶ä»–çš„æ–¹æ³•ï¼Œä¿å­˜å„ä¸ªå­æ ‘çš„èŠ‚ç‚¹æ ‘ å’Œ è€ƒè™‘å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼ˆAVLæ ‘ï¼‰çš„é¢‘ç¹ä¿®æ”¹æƒ…å†µã€‚

# å…¬å…±ç¥–å…ˆ

## 236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return None
        
        if root.val in [p.val, q.val]:
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        if left and right:  # ä¸¤ä¸ªèŠ‚ç‚¹åœ¨ä¸¤è¾¹
            return root
        elif left:  # å³è¾¹æ— pqï¼Œéƒ½åœ¨å·¦è¾¹ï¼Œå·¦è¾¹è®¿é—®çš„æ—¶å€™ï¼Œä¼šå…ˆè®¿é—®åˆ°æ›´é«˜çš„ç‚¹ï¼Œå³ä¸ºä¸¤è€…çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
            return left
        else:       # å·¦è¾¹æ— pqï¼Œç†è®ºåŒä¸Š
            return right
```

## 235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

é¢˜è§£ï¼šå¦‚æœèŠ‚ç‚¹çš„æ•°å€¼åœ¨ç›®æ ‡åŒºé—´å°±æ˜¯æœ€è¿‘å…¬å…±ç¥–å…ˆ

```python
class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        ancestor = root
        while True:
            if p.val < ancestor.val and q.val < ancestor.val:
                ancestor = ancestor.left
            elif p.val > ancestor.val and q.val > ancestor.val:
                ancestor = ancestor.right
            else:
                break
        return ancestor
```

# å‰ªæ

## 450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹ï¼ˆä¸­ç­‰ï¼‰
https://leetcode-cn.com/problems/delete-node-in-a-bst

é¢˜è§£ï¼šåˆ é™¤ä¹‹åéœ€è¦è°ƒæ•´äºŒå‰æ ‘ã€‚

```python
class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        """
        æ€è·¯ï¼š
        æ‰¾åˆ°å¾…åˆ èŠ‚ç‚¹çš„å³å­æ ‘ä¸Šçš„æœ€å°å€¼ä½œä¸ºä»£æ›¿å€¼
        """
        if not root: return None
        if root.val == key:
            if not root.left: return root.right
            if not root.right: return root.left
            cur = root.right  # å³å­æ ‘ä¸­çš„æœ€å·¦èŠ‚ç‚¹
            while cur.left:
                cur = cur.left
            root.val = cur.val
            root.right = self.deleteNode(root.right, cur.val)
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)
        else:
            root.left = self.deleteNode(root.left, key)
        
        return root
```

## 669. ä¿®å‰ªäºŒå‰æœç´¢æ ‘
https://leetcode-cn.com/problems/trim-a-binary-search-tree/

é¢˜ç›®æè¿°ï¼šç»™ä½ äºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼ŒåŒæ—¶ç»™å®šæœ€å°è¾¹ç•Œ`low` å’Œæœ€å¤§è¾¹ç•Œ `high`ã€‚é€šè¿‡ä¿®å‰ªäºŒå‰æœç´¢æ ‘ï¼Œä½¿å¾—æ‰€æœ‰èŠ‚ç‚¹çš„å€¼åœ¨`[low, high]`ä¸­ã€‚ä¿®å‰ªæ ‘ä¸åº”è¯¥æ”¹å˜ä¿ç•™åœ¨æ ‘ä¸­çš„å…ƒç´ çš„ç›¸å¯¹ç»“æ„ï¼ˆå³ï¼Œå¦‚æœæ²¡æœ‰è¢«ç§»é™¤ï¼ŒåŸæœ‰çš„çˆ¶ä»£å­ä»£å…³ç³»éƒ½åº”å½“ä¿ç•™ï¼‰ã€‚ å¯ä»¥è¯æ˜ï¼Œå­˜åœ¨å”¯ä¸€çš„ç­”æ¡ˆã€‚
æ‰€ä»¥ç»“æœåº”å½“è¿”å›ä¿®å‰ªå¥½çš„äºŒå‰æœç´¢æ ‘çš„æ–°çš„æ ¹èŠ‚ç‚¹ã€‚æ³¨æ„ï¼Œæ ¹èŠ‚ç‚¹å¯èƒ½ä¼šæ ¹æ®ç»™å®šçš„è¾¹ç•Œå‘ç”Ÿæ”¹å˜ã€‚

```python
class Solution:
    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
        if not root: return None
        if root.val < low: 
            return self.trimBST(root.right, low, high)
        elif root.val > high: 
            return self.trimBST(root.left, low, high)
        else:
            root.left = self.trimBST(root.left, low, high)
            root.right = self.trimBST(root.right, low, high)
            return root
```

# æ„é€ 

## 701. äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œï¼ˆä¸­ç­‰ï¼‰
https://leetcode-cn.com/problems/insert-into-a-binary-search-tree

> ğŸ“Œå†™é€’å½’çš„æ—¶å€™ï¼Œè¦è€ƒè™‘çš„æ˜¯baseæƒ…å†µï¼Œåœ¨äºŒå‰æ ‘ä¸­å°¤ä¸ºå¸¸è§ã€‚æ‰€æœ‰å­æ ‘ä¹Ÿéƒ½æ˜¯äºŒå‰æ ‘ï¼Œæ‰€ä»¥å¯ä»¥è€ƒè™‘æœ€å°å•å…ƒçš„äºŒå‰æ ‘ã€‚

```python
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root: return TreeNode(val=val, left=None, right=None)
        
        if root.val < val:
            root.right = self.insertIntoBST(root.right, val)
        else:
            root.left = self.insertIntoBST(root.left, val)

        return root
```

## 538. äºŒå‰æœç´¢æ ‘è½¬åŒ–ç´¯åŠ æ ‘ï¼ˆä¸­ç­‰ï¼‰
https://leetcode-cn.com/problems/convert-bst-to-greater-tree

é¢˜ç›®æè¿°ï¼š

![](../images/image_oTvzOhKNbJ.png)

```python
class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        # æ”¹æˆå³ä¸­å·¦çš„éå†æ–¹å¼
        tmpsum = 0
         
        stack = []
        cur = root
        while cur or stack:
            if cur:
                stack.append(cur)
                cur = cur.right
            else: 
                cur = stack.pop(-1)
                tmpsum += cur.val
                cur.val = tmpsum
                cur = cur.left

        return root
```

## 108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘
https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/

é¢˜ç›®æè¿°ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œå…¶ä¸­å…ƒç´ å·²ç»æŒ‰ **å‡åº** æ’åˆ—ï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºä¸€æ£µ **é«˜åº¦å¹³è¡¡** äºŒå‰æœç´¢æ ‘ã€‚

é¢˜è§£ï¼šé€‰æ‹©ä¸­é—´ä½ç½®çš„å€¼ä½œä¸ºæ ¹èŠ‚ç‚¹ã€‚

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if not nums: return None
        
        ind = int(len(nums)/2)
        root = TreeNode(val=nums[ind])

        root.left = self.sortedArrayToBST(nums[:ind])
        root.right = self.sortedArrayToBST(nums[ind+1:])

        return root
```

## 96. ä¸åŒçš„äºŒå‰æœç´¢æ ‘
https://leetcode-cn.com/problems/unique-binary-search-trees

é¢˜ç›®æè¿°ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•° `n` ï¼Œæ±‚æ°ç”± `n` ä¸ªèŠ‚ç‚¹ç»„æˆä¸”èŠ‚ç‚¹å€¼ä» `1` åˆ° `n` äº’ä¸ç›¸åŒçš„ **äºŒå‰æœç´¢æ ‘** æœ‰å¤šå°‘ç§ï¼Ÿè¿”å›æ»¡è¶³é¢˜æ„çš„äºŒå‰æœç´¢æ ‘çš„ç§æ•°ã€‚

é¢˜è§£ï¼šåŠ¨æ€è§„åˆ’

-   å¤‡å¿˜å½•
    ```python
    class Solution:
        def numTrees(self, n: int) -> int:
            """
            ä¸¾ä¾‹ï¼šn = 5ï¼Œå‡è®¾rootèŠ‚ç‚¹é€‰3ï¼Œåˆ™å·¦å­æ ‘{1ï¼Œ2}æ’ï¼Œå³å­æ ‘{4ï¼Œ5}æ’
            """
            memo = {}
            def compute(start, end):
                if start >= end: return 1

                key = "{}-{}".format(start, end)
                if key in memo:
                    return memo[key]

                sum = 0
                for i in range(start, end+1):
                    tkey = "{}-{}".format(start, i-1)
                    if tkey in memo:
                        left = memo[tkey]
                    else:
                        left = compute(start, i-1)

                    tkey = "{}-{}".format(i+1, end)
                    if tkey in memo:
                        right = memo[tkey]
                    else:
                        right = compute(i+1, end)
                    sum += left * right
                
                memo[key] = sum
                return sum
            
            return compute(1, n)

    ```
-   dptable
    ```python
    class Solution:
        def numTrees(self, n):
            # G(x): è®°å½•xé•¿åº¦çš„æœ‰åºæ•°ç»„ï¼Œæ»¡è¶³æ¡ä»¶çš„ç§æ ‘
            G = [0]*(n+1)
            G[0], G[1] = 1, 1

            for i in range(2, n+1):
                for j in range(1, i+1):
                    G[i] += G[j-1] * G[i-j]

            return G[n]

    ```
    -   æ—¶é—´å¤æ‚åº¦ : O(n^2)ï¼Œå…¶ä¸­ n è¡¨ç¤ºäºŒå‰æœç´¢æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚G(n) å‡½æ•°ä¸€å…±æœ‰ n ä¸ªå€¼éœ€è¦æ±‚è§£ï¼Œæ¯æ¬¡æ±‚è§£éœ€è¦ O(n) çš„æ—¶é—´å¤æ‚åº¦ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º O(n^2)ã€‚
    -   ç©ºé—´å¤æ‚åº¦ : O(n)ã€‚æˆ‘ä»¬éœ€è¦ O(n) çš„ç©ºé—´å­˜å‚¨ Gæ•°ç»„ã€‚

## 95. ä¸åŒçš„äºŒå‰æœç´¢æ ‘II
https://leetcode-cn.com/problems/unique-binary-search-trees-ii

é¢˜ç›®æè¿°ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•° `n` ï¼Œè¯·ä½ ç”Ÿæˆå¹¶è¿”å›æ‰€æœ‰ç”± `n` ä¸ªèŠ‚ç‚¹ç»„æˆä¸”èŠ‚ç‚¹å€¼ä» `1` åˆ° `n` äº’ä¸ç›¸åŒçš„ä¸åŒ **äºŒå‰æœç´¢æ ‘** ã€‚å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›ç­”æ¡ˆã€‚

é¢˜è§£ï¼šå›æº¯

```python
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        
        def compute(start, end):
            res = []

            if start>end: return [None]

            if start==end: return [TreeNode(val=start)]
            
            # è½®æµä¸ºå¤´èŠ‚ç‚¹
            for i in range(start, end+1):
                left = compute(start, i-1)
                right = compute(i+1, end)
                for l in left:
                    for r in right:
                        res.append(TreeNode(val=i, left=l, right=r))
            return res
                
        return compute(1, n)
```
